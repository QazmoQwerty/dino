/*	Things to do:
	a) Write down syntax
	b) Code a Lexer
	c) Code a Parser
	d) Code an Action Tree
	e) Run the Action Tree (with an interpreter OR a compiler)
	*compiler would be written with the LLVM library.
	
	Ideas: ****************************************************************************
		 - Things starting with capitals are public, while small letters make private
			(this setting can be overriden of course)
		 - Each variable will link (behind the scenes) to all the variables that are reactive to it
	*************************************************************************************
*/

void Foo() {
	'1'.GetType() == char
	"1".GetType() == string
	2.5.GetType() == ? // TODO - decide between float and double
}

include Std
MyType x = MyType("wo", 1, 2)
print(x.num4)
x.num1 = 10

interface MyInterface {
	int Funct1()
	string FunkyFunc(string s)
}

int[] x
x = new int[]{1, 2, 4, 4}

int x = 3
reactive MyType n = new reactive MyType() { return new MyType("name", x, x + 1)}

type MyType {
	// Variables:
	string name // private - lowercase
	int num1, num2
	reactive int num3
	
	// Reactive array of strings: will create a new array whenever values are changed
	reactive string[] valueStrings1
	
	// Array of reactive strings: will change individual values
	(reactive string)[] valueStrings2
	
	// Reactive types can be set outside of constructor too
	reactive int num4 = new reactive int() { int x = 2 + num2 + 1; return x }
	
	// Member Functions:
	MyType(string name, int num1, int num2) {	// name, num1, num2 are set automatically
		this.name = name
		this.num1 = num1
		this.num2 = num2
		num3 = new reactive int() { return this.num1 + this.num2 }
		valueStrings1 = new reactive string[]() { return [name, num1.ToString(), num2.ToString(), num3.ToString()] }
		valueStrings2 = new (reactive string)[]{
			reactive string() { return this.name }, 
			reactive string() { return this.num1.ToString() },
			reactive string() { return this.num2.ToString() },
			reactive string() { return num3.ToString() },
		}
	}
	
	bool CalcNum() {
		if num1 .!=. num2 .!=. 4 {}			// (num1 != num2 && num2 != 4)
		if num1 .<=. 4 .>=. num2 {}			// (num1 <= 4 && 4 >= num2)
		if num1 .<. 4 .<. num2 .==. 2 {}	// (num1 < 4 && 4 < num2 && num2 == 2)
		else if valueStrings1[0] == "omg" {
			return name == "wow"
		}
		else return false
	}
	
	// Note: this function is private (small letter)
	int calcNum(int n) {
		iter i(0, 100) pass
		iter i(x) pass
		refIter i(x) pass
		Std.iter(0, 100, () {
			
		})	
		for int i = {1, 2, 3, 4} {}
		for int i = 0; i < 100; i++ {}
		
		while !Func(n) {
			n*=2
		}
		
		reactive int r = reactive int(){ return n + 3 }
		auto func = int(int x){ return x + n }
		return r + func(5)	// returns (n + 3) + (5 + n) = 8 + 2 * n
		
		switch n {
			case 1 {
				print(1)
			}
			case 1, 2 {
				print(2)
			}
			case 2 {
				print("wow")
			}
			case 3, 4 {
				
			}
			
			default {
				
			}
		}
	}
}